const express = require('express');
const { body, validationResult } = require('express-validator');
const geminiService = require('../services/geminiService');
const enhancedGeminiAnalyst = require('../services/enhancedGeminiAnalyst');
const cleanGeminiService = require('../services/cleanGeminiService');
const workingGeminiService = require('../services/workingGeminiService');
const router = express.Router();

// Mock middleware for authentication
const authenticateToken = (req, res, next) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (!token) {
    return res.status(401).json({ success: false, message: 'Access token required' });
  }
  req.userId = 'mock-user-id';
  next();
};

// Note: AI responses are now handled by the Gemini service

// @route   POST /api/chat/message
// @desc    Send a message to AI mentor
// @access  Public (for testing)
router.post('/message', [
  // authenticateToken, // Temporarily disabled for testing
  body('message').trim().isLength({ min: 1, max: 1000 }).withMessage('Message must be between 1-1000 characters'),
  body('conversationId').optional().isString()
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { message, conversationId, skill, currentChapter } = req.body;

    // Build dynamic context - don't assume everything is about Data Science
    const context = {
      currentChapter: currentChapter || null,
      progress: req.body.progress || null,
      lastQuizScore: req.body.lastQuizScore || null,
      skillLevel: req.body.skillLevel || null,
      goals: skill ? `Learn ${skill}` : null,
      skill: skill || null // Only set skill if explicitly provided
    };

    console.log(`💬 [CHAT API] Processing message: "${message}"`);
    console.log(`💬 [CHAT API] Context:`, context);

    // Use enhanced Gemini analyst for REAL AI responses (no fallbacks)
    let aiResponse;
    try {
      aiResponse = await enhancedGeminiAnalyst.mentorChat(message, context);
    } catch (error) {
      console.log('Enhanced analyst failed, using working service fallback');
      aiResponse = await workingGeminiService.chatMentor(message, context);
    }

    console.log(`✅ [CHAT API] AI response generated by: ${aiResponse.generatedBy}`);

    // Handle rate limit responses (aiResponse.success can be true even for rate limits)
    if (aiResponse.isRateLimit || !aiResponse.success) {
      const response = {
        id: Date.now().toString(),
        conversationId: conversationId || `conv_${Date.now()}`,
        userMessage: {
          content: message,
          timestamp: new Date(),
          type: 'user'
        },
        aiResponse: {
          content: aiResponse.message,
          timestamp: new Date(),
          type: 'ai',
          confidence: 0.95,
          generatedBy: aiResponse.generatedBy || 'Gemini API (Rate Limited)',
          isRateLimit: true,
          sources: []
        }
      };

      return res.json({
        success: true,
        data: response,
        note: 'Rate limited - this is expected behavior, not a mock response'
      });
    }

    const response = {
      id: Date.now().toString(),
      conversationId: conversationId || `conv_${Date.now()}`,
      userMessage: {
        content: message,
        timestamp: new Date(),
        type: 'user'
      },
      aiResponse: {
        content: aiResponse.message,
        timestamp: new Date(),
        type: 'ai',
        confidence: 0.95,
        generatedBy: aiResponse.generatedBy,
        sources: aiResponse.suggestedResources || []
      }
    };

    res.json({
      success: true,
      data: response
    });

  } catch (error) {
    console.error('❌ [CHAT API] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Gemini AI error: ' + error.message,
      error: error.message,
      note: 'This is a real AI error, not a mock response. Please check Gemini API configuration.'
    });
  }
});

// @route   GET /api/chat/conversations
// @desc    Get user's chat conversations
// @access  Private
router.get('/conversations', authenticateToken, (req, res) => {
  try {
    const conversations = [
      {
        id: 'conv_1',
        title: 'Python Learning Path',
        lastMessage: 'What specific area of Python would you like to focus on?',
        timestamp: new Date(Date.now() - 3600000),
        messageCount: 8
      },
      {
        id: 'conv_2',
        title: 'Machine Learning Basics',
        lastMessage: 'Which aspect would you like to dive deeper into?',
        timestamp: new Date(Date.now() - 86400000),
        messageCount: 12
      },
      {
        id: 'conv_3',
        title: 'Career Transition Advice',
        lastMessage: 'What\'s your current background? I can provide more specific guidance!',
        timestamp: new Date(Date.now() - 172800000),
        messageCount: 6
      }
    ];

    res.json({
      success: true,
      data: conversations
    });
  } catch (error) {
    console.error('Get conversations error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// @route   GET /api/chat/conversation/:id
// @desc    Get specific conversation messages
// @access  Private
router.get('/conversation/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;

    const conversation = {
      id,
      title: 'Python Learning Path',
      messages: [
        {
          id: 'msg_1',
          content: 'Hi! I\'m your AI mentor. How can I help you with your Data Science journey today?',
          type: 'ai',
          timestamp: new Date(Date.now() - 7200000)
        },
        {
          id: 'msg_2',
          content: 'How do I improve my Python coding skills?',
          type: 'user',
          timestamp: new Date(Date.now() - 7000000)
        },
        {
          id: 'msg_3',
          content: `Great question! Here are effective ways to improve your Python skills:

**1. Practice Regularly**
- Solve coding challenges on HackerRank, LeetCode
- Work on small projects daily (even 30 minutes helps)

**2. Read Quality Code**
- Study open-source projects on GitHub
- Follow Python style guides (PEP 8)

**3. Build Projects**
- Start with simple scripts, progress to complex applications
- Focus on data science projects since that's your path

**4. Learn Libraries**
- Master NumPy, Pandas, Matplotlib
- Explore Scikit-learn for ML

**5. Join Communities**
- Python Discord, Reddit r/Python
- Attend local Python meetups

What specific area of Python would you like to focus on?`,
          type: 'ai',
          timestamp: new Date(Date.now() - 6800000)
        }
      ],
      createdAt: new Date(Date.now() - 86400000),
      updatedAt: new Date(Date.now() - 3600000)
    };

    res.json({
      success: true,
      data: conversation
    });
  } catch (error) {
    console.error('Get conversation error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// @route   DELETE /api/chat/conversation/:id
// @desc    Delete a conversation
// @access  Private
router.delete('/conversation/:id', authenticateToken, (req, res) => {
  try {
    const { id } = req.params;

    res.json({
      success: true,
      message: 'Conversation deleted successfully',
      data: { deletedId: id }
    });
  } catch (error) {
    console.error('Delete conversation error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// @route   POST /api/chat/feedback
// @desc    Submit feedback on AI response
// @access  Private
router.post('/feedback', [
  authenticateToken,
  body('messageId').isString(),
  body('rating').isIn(['helpful', 'not_helpful']),
  body('comment').optional().trim().isLength({ max: 500 })
], (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { messageId, rating, comment } = req.body;

    res.json({
      success: true,
      message: 'Feedback submitted successfully',
      data: {
        messageId,
        rating,
        comment,
        timestamp: new Date()
      }
    });
  } catch (error) {
    console.error('Submit feedback error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

// @route   GET /api/chat/suggestions
// @desc    Get suggested questions based on user progress
// @access  Private
router.get('/suggestions', authenticateToken, async (req, res) => {
  try {
    // Get user progress (you can implement this based on your database)
    const userProgress = {}; // TODO: Fetch from database based on req.userId

    // Generate suggestions using Gemini
    const suggestions = await geminiService.generateSuggestions(userProgress);

    res.json({
      success: true,
      data: suggestions
    });
  } catch (error) {
    console.error('Get suggestions error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error'
    });
  }
});

module.exports = router;
